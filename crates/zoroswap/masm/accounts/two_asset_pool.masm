use.miden::active_account
use.miden::native_account
use.miden::output_note


#! CONSTANTS
const.MAX_COVERAGE_RATIO = 0x0002 # 200%


#! ERRORS
const.ERR_MAX_COVERAGE_RATIO_EXCEEDED ="Max coverage ratio exceeded"
const.ERR_RESERVE_WITH_SLIPPAGE_EXCEEDS_ASSET_BALANCE ="Reserve with slippage exceeds asset balance"
const.ERR_RESERVE_EXCEEDS_RESERVE_WITH_SLIPPAGE ="Reserve exceeds reserve with slippage"


#! MEM STRUCTURE
#! DYNAMIC PROC ADDRESS
const.DYNAMIC_PROC_ADDR = 0x0004


const.DEPOSIT_ASSET_LOC = 0x00A0
const.DEPOSIT_KEY_LOC = 0x00A4


#! STORAGE STRUCTURE
#! SINGLE ASSET
#! pool state: [liabilities, reserve, reserve_with_slippage, 0]
#! fees: [swap_fee, backstop_fee, protocol_fee, 0 ]
#! curve: c, beta

const.ASSET0_ID_ADDR = 0x0000
const.ASSET1_ID_ADDR = 0x0001

const.POOL0_STATE_ADDR = 0x0002
const.POOL1_STATE_ADDR = 0x0003

const.POOL0_FEES_ADDR = 0x0004
const.POOL1_FEES_ADDR = 0x0005

const.POOL0_CURVE_ADDR = 0x0006
const.POOL1_CURVE_ADDR = 0x0007


const.ASSETS_MAPPING_SLOT = 0x0008
const.POOL_STATE_MAPPING_SLOT = 0x0009

const.USER_DEPOSITS_MAPPING_SLOT = 0x000A


#! INDEXES
const.LIABILITIES_INDEX = 0x0000
const.RESERVE_INDEX = 0x0001
const.RESERVE_WITH_SLIPPAGE_INDEX = 0x0002

const.SWAP_FEE_INDEX = 0x0000
const.BACKSTOP_FEE_INDEX = 0x0001
const.PROTOCOL_FEE_INDEX = 0x0002

const.C_INDEX = 0x0000
const.BETA_INDEX = 0x0001




#! SETTERS
#!
#! Inputs: [ASSET, liabilities, reserve, reserve_with_slippage, pad(9)]
#! Outputs: []
#!
export.swap_in_pool0
    exec.native_account::add_asset
    # => [ASSET', liabilities, reserve, reserve_with_slippage, pad(9)]
    dropw # could use ASSET' to validate pools states
    exec.set_pool0_state
    # => []
end



#! Sets POOL STATE
#!
#! Inputs: [ASSET, liabilities, reserve, reserve_with_slippage]
#! Outputs: []
#!
#! @dev TODO: compare reserve with slippage with actual asset balances 
export.set_pool_state
    dupw
    movdnw.2
    # =>[ASSET, liabilities, reserve, reserve_with_slippage, 0,ASSET]

    # @dev: esure reserve never > reserve_with_slippage
    dup.5  
    # =>[reserve, ASSET, liabilities, reserve, reserve_with_slippage, 0, ASSET]
    dup.7
    # => [reserve_with_slippage, reserve, ASSET, liabilities, reserve, reserve_with_slippage, 0, ASSET]
    
    lte assert.err=ERR_RESERVE_EXCEEDS_RESERVE_WITH_SLIPPAGE
    ## => [ASSET, liabilities, reserve, reserve_with_slippage, 0, ASSET]

    # @dev:ensure reserves < max_coverage_ratio * liabilities
    dup.6 dup.5 mul.MAX_COVERAGE_RATIO
    # => [liablities * max_coverage_ratio, reserve_with_slippage, ASSET, liabilities, reserve, reserve_with_slippage, 0, ASSET]
    lt assert.err=ERR_MAX_COVERAGE_RATIO_EXCEEDED
    ## => [ASSET, liabilities, reserve, reserve_with_slippage, 0, ASSET]

    # => [ASSET, liabilities, reserve, reserve_with_slippage, 0, ASSET]
    
    exec.address_from_asset 
    exec.active_account::get_balance
    # => [asset_balance, liabilities, reserve, reserve_with_slippage, 0, ASSET]

    dup.3 swap

    # => [asset_balance, reserve_with_slippage, pool_state_loc, liabilities, reserve, reserve_with_slippage, 0, ASSET]
    lte assert.err=ERR_RESERVE_WITH_SLIPPAGE_EXCEEDS_ASSET_BALANCE
    # => [liabilities, reserve, reserve_with_slippage, 0, ASSET]
    #push.0
   
    # => [ POOL_STATE, ASSET]
    swapw 
    # => [ ASSET, POOL_STATE]
    #reversew drop drop push.0.0
    exec.address_word_from_asset
    
    # => [asset_faucet_id_prefix, asset_faucet_id_suffix, 0, 0, POOL_STATE]
    # => [POOL_KEY, POOL_STATE]
    push.POOL_STATE_MAPPING_SLOT
    exec.native_account::set_map_item
    
    dropw
    # => []  
end

export.set_pool0_state
    #push.POOL0_STATE_ADDR
    push.0.0.0.0 # asset index
    # => [ASSET_0_INDEX, liabilities, reserve, reserve_with_slippage, 0]
    # => [ 0,0,0,0, liabilities, reserve, reserve_with_slippage, 0]
    push.ASSETS_MAPPING_SLOT
    exec.active_account::get_map_item
    
    exec.set_pool_state
    
end


export.set_pool1_state
    
    #push.POOL1_STATE_ADDR 
    #push.ASSET1_ID_ADDR 
    push.1.0.0.0
    push.ASSETS_MAPPING_SLOT
    exec.active_account::get_map_item


    
    exec.set_pool_state
    
end


proc.debug_storage
    push.POOL1_CURVE_ADDR exec.active_account::get_item
    push.POOL0_CURVE_ADDR exec.active_account::get_item
    push.POOL1_FEES_ADDR exec.active_account::get_item
    push.POOL0_FEES_ADDR exec.active_account::get_item
    push.POOL1_STATE_ADDR exec.active_account::get_item
    push.POOL0_STATE_ADDR exec.active_account::get_item
    push.ASSET1_ID_ADDR exec.active_account::get_item
    push.ASSET0_ID_ADDR exec.active_account::get_item
    debug.stack
    dropw
    dropw
    dropw
    dropw
    dropw
    dropw
    dropw
    dropw
end



#! GETTERS
#! Returns ASSET ADDRESS
#!
#! Inputs: [0, 0, 0, 0]
#! Outputs: [asset_accout_prefix, asset_account_suffix, 0, 0]
#!
export.get_asset0
    push.ASSET0_ID_ADDR exec.active_account::get_item
    swapw dropw
end
export.get_asset1
    push.ASSET1_ID_ADDR exec.active_account::get_item
    swapw dropw
end



#! Returns POOL STATE
#!
#! Inputs: [0, 0, 0, 0]
#! Outputs: [liabilities, reserve, reserve_with_slippage, 0]
#!
export.get_pool0_state
    push.0 # pool index
    call.get_pool_asset
    # => [pool0_state_addr]
    push.POOL_STATE_MAPPING_SLOT
    exec.active_account::get_item
    # => [liabilities, reserve, reserve_with_slippage, 0]
    swapw dropw
    # => [liabilities, reserve, reserve_with_slippage]
end
export.get_pool1_state
    push.1 # pool index
    call.get_pool_asset
    # => [POOL_ASSET_ID]
    push.POOL_STATE_MAPPING_SLOT
    exec.active_account::get_item

    swapw dropw
end

#! Returns POOL ASSET ID
#!
#! Inputs: [pool_index]
#! Outputs: [asset_id_prefix, asset_id_suffix, 0, 0]
#!
export.get_pool_asset
    # fill in the index to a word to server as the mapping key
    push.0.0.0 
    # => [POOL_IMDEX]
    push.ASSETS_MAPPING_SLOT
    exec.active_account::get_map_item
end

#! Returns POOL FEES
#!
#! Inputs: [0, 0, 0, 0]
#! Outputs: [swap_fee, backstop_fee, protocol_fee, 0]
#!
export.get_pool0_fees
    push.POOL0_FEES_ADDR
    # => [pool0_fees_addr]
    
    exec.active_account::get_item
    # => [swap_fee, backstop_fee, protocol_fee, 0]
    swapw dropw
end
export.get_pool1_fees
    push.POOL1_FEES_ADDR
    # => [pool1_fees_addr]
    
    exec.active_account::get_item
    # => [swap_fee, backstop_fee, protocol_fee, 0]
    swapw dropw
end


#! Returns POOL CURVE
#!
#! Inputs: [0, 0, 0, 0]
#! Outputs: [c, beta, 0, 0]
#!

export.get_pool0_curve
    push.POOL0_CURVE_ADDR
    # => [pool0_curve_addr]
    
    exec.active_account::get_item
    # => [c, beta, 0, 0]
    swapw dropw
end
export.get_pool1_curve
    push.POOL1_CURVE_ADDR
    # => [pool1_curve_addr]
    
    exec.active_account::get_item
    # => [c, beta, 0, 0]
    swapw dropw
end




# WALLET FUNCTIONS

#! Adds the provided asset to the active account.
#!
#! Inputs:  [ASSET, reserve, reserve_with_slippage, liabilities, 0, pad(8)]
#! Outputs: [pad(16)]
#!
#! Where:
#! - ASSET is the asset to be received, can be fungible or non-fungible
#!
#! Panics if:
#! - the same non-fungible asset already exists in the account.
#! - adding a fungible asset would result in amount overflow, i.e.,
#!   the total amount would be greater than 2^63.
#!
#! Invocation: call
export.receive_asset
    exec.native_account::add_asset
    # => [ASSET', reserve, reserve_with_slippage, liabilities, 0, pad(8)]

    procref.validate_and_update_state mem_storew_be.DYNAMIC_PROC_ADDR dropw push.DYNAMIC_PROC_ADDR
    dynexec

    # => [pad(16)]
end

#proc.validate_and_update_state
#   push.0 drop
#end

proc.validate_and_update_state
   exec.set_pool_state
end

#! Adds the provided asset to the an output note.
#!
#! Inputs:  [ASSET, noteid, 0,0,0, liabilities, reserve, reserve_with_slippage, 0, pad(4)]
#! Outputs: [pad(16)]
#!
#! Where:
#! - ASSET is the asset to be received, can be fungible or non-fungible
#!
#! Panics if:
#! - the same non-fungible asset already exists in the account.
#! - adding a fungible asset would result in amount overflow, i.e.,
#!   the total amount would be greater than 2^63.
#!
export.move_asset_to_note
    exec.native_account::remove_asset
    # => [ASSET, note_idx, 0,0,0, liabilities, reserve, reserve_with_slippage, 0, pad(4)]

    dupw dup.8 movdn.4
    # => [ASSET, note_idx, ASSET, note_idx,0,0,0, liabilities, reserve, reserve_with_slippage, 0, pad(4)]

    exec.output_note::add_asset
    
    # => [ASSET, note_idx, 0,0,0, liabilities, reserve, reserve_with_slippage, 0, pad(4)]
    # @note this has to be dynamic
    swapw.1 dropw 
    
    
    exec.set_pool_state

    dropw
end

#! add new deposit: receive asset, update deposit mapping
#!
#! Inputs: [ASSET, POOL_STATE,user_id_suffix, user_id_prefix]
#! Outputs: [share_amount]
#!
export.deposit
    mem_storew_be.DEPOSIT_ASSET_LOC

    exec.receive_asset

    padw
    mem_loadw_be.DEPOSIT_ASSET_LOC
    # => [ASSET, beneficiary_suffix, beneficiary_prefix]

    exec.get_user_deposit_key
    # => [KEY]
    mem_storew_be.DEPOSIT_KEY_LOC
    dropw padw
 
    mem_loadw_be.DEPOSIT_ASSET_LOC
    exec.extract_asset_amount
    # => [amount]
    exec.compute_deposit_shares
    # => [share_amount]

    # @todo: factor out into proc.add_to_map_item
    push.0.0.0
    # => [SHARE_AMOUNT]
    padw
    mem_loadw_be.DEPOSIT_KEY_LOC
    # => [KEY, SHARE_AMOUNT]
    push.USER_DEPOSITS_MAPPING_SLOT 
    # => [slot, KEY, SHARE_AMOUNT]
    exec.active_account::get_map_item
    # => [OLD_SHARE_AMOUNT, SHARE_AMOUNT]
    drop drop drop
    # => [old_share_amount, SHARE_AMOUNT]
    swap.3 drop drop drop
    # => [old_share_amount, share_amount]
    add 
    # => [new_share_amount]
    push.0.0.0
    # => [NEW_SHARE_AMOUNT]
    mem_storew_be.DEPOSIT_KEY_LOC
    push.USER_DEPOSITS_MAPPING_SLOT
    exec.native_account::set_map_item
    # => [OLD_MAP_ROOT, OLD_MAP_VALUE]
    dropw dropw
end

#! Returns user LP shares mapping  key
#!
#! Inputs: [ASSET, user_id_suffix, user_id_prefix]
#! Outputs: [share_amount]
#!
proc.get_user_deposit_key
    exec.address_from_asset
    # => [asset_account_prefix, asset_account_suffix, user_id_suffix, user_id_prefix]
    # => [KEY]
end

#! Returns user LP shares emitted for deposit amount
#!
#! Inputs: [amount, KEY]
#! Outputs: [share_amount]
#!
proc.compute_deposit_shares
    # @todo: implement
    movup.4 dropw
end

#! Returns user LP amount key
#!
#! Inputs: [ASSET, beneficiary_suffix, beneficiary_prefix]
#! Outputs: [KEY]
#!
proc.make_user_deposit_key
    swap.2 drop swap.2 drop
end

#! Returns ASSET AMMOUNT 
#! Inputs: [ASSET]
#! Outputs: [amount]
#!
proc.extract_asset_amount
    drop drop drop
end




#! UTILS
#! Returns ASSET ADDRESS followd by two 0 felts
#!
#! Inputs: [ASSET]
#! Outputs: [asset_accout_prefix, asset_account_suffix, 0, 0]
#!
proc.address_word_from_asset
    push.0 swap.3 drop
    push.0 swap.4 drop
end

#! Returns ASSET ADDRESS
#!
#! Inputs: [ASSET]
#! Outputs: [asset_accout_prefix, asset_account_suffix]
#!
proc.address_from_asset
    swap.2 drop
    swap.2 drop
end



    
