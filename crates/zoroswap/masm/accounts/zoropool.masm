use miden::protocol::active_account
use miden::protocol::native_account
use miden::protocol::output_note


#! CONSTANTS
const MAX_COVERAGE_RATIO = 0x0002 # 200%


#! ERRORS
const ERR_MAX_COVERAGE_RATIO_EXCEEDED ="Max coverage ratio exceeded"
const ERR_RESERVE_WITH_SLIPPAGE_EXCEEDS_ASSET_BALANCE ="Reserve with slippage exceeds asset balance"
const ERR_RESERVE_EXCEEDS_RESERVE_WITH_SLIPPAGE ="Reserve exceeds reserve with slippage"
const ERR_LP_WITHDRAW_AMOUNT_EXCEEDS_USER_LP_SHARES ="LP withdrawal amount exceeds user LP shares"


#! MEM STRUCTURE
#! DYNAMIC PROC ADDRESS
const DYNAMIC_PROC_ADDR = 0x0004


const DEPOSIT_ASSET_LOC = 0x00A0
const DEPOSIT_KEY_LOC = 0x00A4
const WITHDRAW_KEY_LOC = 0x00A4

const BOUNCE_ASSET_LOC = 0x00A8

const LP_SHARES_LOC = 0x00AC
const LP_SHARES_AMOUNT_ADDR = LP_SHARES_LOC + 3

const HELPER_SLOT_P_LOC = 0x00B0
const HELPER_SLOT_S_LOC = 0x00B1


#! STORAGE STRUCTURE
#! SINGLE ASSET
#! pool state: [liabilities, reserve, reserve_with_slippage, 0]
#! fees: [swap_fee, backstop_fee, protocol_fee, 0 ]
#! curve: c, beta
const ASSETS_MAPPING_SLOT = word("zoroswap::assets")
const POOL_STATE_MAPPING_SLOT = word("zoroswap::pool_state")

const USER_DEPOSITS_MAPPING_SLOT = word("zoroswap::user_deposits")


const POOL_CURVE_MAPPING_SLOT = word("zoroswap::pool_curve")
const POOL_FEES_MAPPING_SLOT = word("zoroswap::fees")


#! INDEXES
const LIABILITIES_INDEX = 0x0000
const RESERVE_INDEX = 0x0001
const RESERVE_WITH_SLIPPAGE_INDEX = 0x0002

const SWAP_FEE_INDEX = 0x0000
const BACKSTOP_FEE_INDEX = 0x0001
const PROTOCOL_FEE_INDEX = 0x0002

const C_INDEX = 0x0000
const BETA_INDEX = 0x0001




#! Sets POOL STATE
#!
#! Inputs: [ASSET, liabilities, reserve, reserve_with_slippage]
#! Outputs: []
#!
#! TODO: compare reserve with slippage with actual asset balances
pub proc set_pool_state
    dupw
    movdnw.2
    # =>[ASSET, liabilities, reserve, reserve_with_slippage, 0,ASSET]

    # ensure reserve never > reserve_with_slippage
    dup.5
    # =>[reserve, ASSET, liabilities, reserve, reserve_with_slippage, 0, ASSET]
    dup.7
    # => [reserve_with_slippage, reserve, ASSET, liabilities, reserve, reserve_with_slippage, 0, ASSET]
    lte assert.err=ERR_RESERVE_EXCEEDS_RESERVE_WITH_SLIPPAGE
    ## => [ASSET, liabilities, reserve, reserve_with_slippage, 0, ASSET]

    # ensure reserves < max_coverage_ratio * liabilities
    dup.6 dup.5 mul.MAX_COVERAGE_RATIO
    # => [liablities * max_coverage_ratio, reserve_with_slippage, ASSET, liabilities, reserve, reserve_with_slippage, 0, ASSET]
    lt assert.err=ERR_MAX_COVERAGE_RATIO_EXCEEDED
    ## => [ASSET, liabilities, reserve, reserve_with_slippage, 0, ASSET]

    # => [ASSET, liabilities, reserve, reserve_with_slippage, 0, ASSET]

    exec.address_from_asset
    exec.active_account::get_balance
    # => [asset_balance, liabilities, reserve, reserve_with_slippage, 0, ASSET]

    dup.3 swap
    # => [asset_balance, reserve_with_slippage, pool_state_loc, liabilities, reserve, reserve_with_slippage, 0, ASSET]
    lte assert.err=ERR_RESERVE_WITH_SLIPPAGE_EXCEEDS_ASSET_BALANCE
    # => [liabilities, reserve, reserve_with_slippage, 0, ASSET]
    # => [ POOL_STATE, ASSET]
    swapw
    # => [ ASSET, POOL_STATE]
    #reversew drop drop push.0.0
    exec.address_word_from_asset

    # => [asset_faucet_id_prefix, asset_faucet_id_suffix, 0, 0, POOL_STATE]
    # => [POOL_KEY, POOL_STATE]
    push.POOL_STATE_MAPPING_SLOT[0..2]
    exec.native_account::set_map_item

    dropw
    # => []
end

pub proc set_pool0_state
    #push.POOL0_STATE_ADDR
    push.0.0.0.0 # asset index
    # => [ASSET_0_INDEX, liabilities, reserve, reserve_with_slippage, 0]
    # => [ 0,0,0,0, liabilities, reserve, reserve_with_slippage, 0]
    push.ASSETS_MAPPING_SLOT[0..2]
    exec.active_account::get_map_item

    exec.set_pool_state

end


pub proc set_pool1_state
    push.1.0.0.0
    push.ASSETS_MAPPING_SLOT[0..2]
    exec.active_account::get_map_item

    exec.set_pool_state

end


#! Returns POOL STATE
#!
#! Inputs: [0, 0, 0, 0]
#! Outputs: [liabilities, reserve, reserve_with_slippage, 0]
#!
pub proc get_pool0_state
    push.0 # pool index
    call.get_pool_asset
    # => [faucet_prefix, faucet_suffix, 0, 0, ...] (call frame, KEY = first 4 felts after slot)
    push.POOL_STATE_MAPPING_SLOT[0..2]
    exec.active_account::get_map_item
    # => [liabilities, reserve, reserve_with_slippage, 0]
end
pub proc get_pool1_state
    push.1 # pool index
    call.get_pool_asset
    # => [faucet_prefix, faucet_suffix, 0, 0, ...] (call frame)
    push.POOL_STATE_MAPPING_SLOT[0..2]
    exec.active_account::get_map_item
    # => [liabilities, reserve, reserve_with_slippage, 0]
end

#! Returns POOL ASSET ID
#!
#! Inputs: [pool_index]
#! Outputs: [asset_id_prefix, asset_id_suffix]
#!
pub proc get_pool_asset
    # fill in the index to a word to server as the mapping key
    push.0.0.0
    # => [POOL_IMDEX]
    push.ASSETS_MAPPING_SLOT[0..2]
    exec.active_account::get_map_item
    swap.2 drop
    swap.2 drop
end

#! Returns POOL FEES
#!
#! Inputs: [0, 0, 0, index]
#! Outputs: [swap_fee, backstop_fee, protocol_fee, 0]
#!
#export.get_pool0_fees
#    push.POOL0_FEES_ADDR
#    # => [pool0_fees_addr]
#
#    exec.active_account::get_item
#    # => [swap_fee, backstop_fee, protocol_fee, 0]
#    swapw dropw
#end
#export.get_pool1_fees
#    push.POOL1_FEES_ADDR
#    # => [pool1_fees_addr]
#
#    exec.active_account::get_item
#    # => [swap_fee, backstop_fee, protocol_fee, 0]
#    swapw dropw
#end
pub proc get_pool_fees
    push.0.0.0
    push.POOL_FEES_MAPPING_SLOT[0..2]
    exec.active_account::get_map_item
end


#! Returns POOL CURVE
#!
#! Inputs: [0, 0, 0, 0]
#! Outputs: [c, beta, 0, 0]
#!
pub proc get_pool_curve
    push.0.0.0
    push.POOL_CURVE_MAPPING_SLOT[0..2]
    exec.active_account::get_map_item
    swap.2 drop
    swap.2 drop
end



# WALLET FUNCTIONS

#! Adds the provided asset to the active account.
#!
#! Inputs:  [ASSET, reserve, reserve_with_slippage, liabilities, 0, pad(8)]
#! Outputs: [pad(16)]
#!
#! Where:
#! - ASSET is the asset to be received, can be fungible or non-fungible
#!
#! Panics if:
#! - the same non-fungible asset already exists in the account.
#! - adding a fungible asset would result in amount overflow, i.e.,
#!   the total amount would be greater than 2^63.
#!
#! Invocation: call
pub proc receive_asset
    exec.native_account::add_asset
    # => [ASSET', reserve, reserve_with_slippage, liabilities, 0, pad(8)]

    procref.validate_and_update_state mem_storew_be.DYNAMIC_PROC_ADDR dropw push.DYNAMIC_PROC_ADDR
    dynexec

    # => [pad(16)]
end

#proc validate_and_update_state
#   push.0 drop
#end

proc validate_and_update_state
   exec.set_pool_state
end

#! Adds the provided asset to the an output note.
#!
#! Inputs:  [ASSET, noteid, 0,0,0, liabilities, reserve, reserve_with_slippage, 0, pad(4)]
#! Outputs: [pad(16)]
#!
#! Where:
#! - ASSET is the asset to be received, can be fungible or non-fungible
#!
#! Panics if:
#! - the same non-fungible asset already exists in the account.
#! - adding a fungible asset would result in amount overflow, i.e.,
#!   the total amount would be greater than 2^63.
#!
pub proc move_asset_to_note
    exec.native_account::remove_asset
    # => [ASSET, note_idx, 0,0,0, liabilities, reserve, reserve_with_slippage, 0, pad(4)]

    dupw dup.8 movdn.4
    # => [ASSET, note_idx, ASSET, note_idx,0,0,0, liabilities, reserve, reserve_with_slippage, 0, pad(4)]

    exec.output_note::add_asset

    # => [ASSET, note_idx, 0,0,0, liabilities, reserve, reserve_with_slippage, 0, pad(4)]

    swapw.1 dropw

    exec.set_pool_state
end

#! Move asset from current note and immediately add it to another.
#!
#! Inputs:  [ASSET, noteid]
#! Outputs: [pad(16)]
#!
#! Where:
#! - ASSET is the asset to be bounced, can be fungible or non-fungible
#!
#! Panics if:
#! - the same non-fungible asset already exists in the account.
#! - adding a fungible asset would result in amount overflow, i.e.,
#!   the total amount would be greater than 2^63.
#!
pub proc bounce_asset
    mem_storew_be.BOUNCE_ASSET_LOC
    exec.native_account::add_asset
    dropw
    mem_loadw_be.BOUNCE_ASSET_LOC
    exec.native_account::remove_asset

    exec.output_note::add_asset
end


#! add new deposit: receive asset, update deposit mapping
#!
#! Inputs: [ASSET, POOL_STATE,user_id_suffix, user_id_prefix, lp_amount_out]
#! Outputs: [share_amount]
#!
pub proc deposit
    mem_storew_be.DEPOSIT_ASSET_LOC

    exec.receive_asset
    padw mem_loadw_be.DEPOSIT_ASSET_LOC
    # => [ASSET, beneficiary_suffix, beneficiary_prefix, lp_amount_out]
    exec.get_user_deposit_key
    # => [KEY, lp_amount_out]
    mem_storew_be.DEPOSIT_KEY_LOC
    movup.4
    # => [lp_amount_out, KEY]
    dup mem_store.LP_SHARES_AMOUNT_ADDR
    push.0.0.0
    # => [SHARE_AMOUNT, KEY]
    swapw
    # => [KEY, SHARE_AMOUNT]
    push.USER_DEPOSITS_MAPPING_SLOT[0..2]
    # => [slot_p, slot_s, KEY, SHARE_AMOUNT]
    exec.add_to_map_item

    # update total supply
    mem_load.LP_SHARES_AMOUNT_ADDR push.0.0.0
    padw mem_loadw_be.DEPOSIT_KEY_LOC
    # => [KEY, SHARE_AMOUNT]
    exec.get_lp_shares_total_supply_key
    # => [TOTAL_SUPPLY_KEY, SHARE_AMOUNT]
    push.USER_DEPOSITS_MAPPING_SLOT[0..2]
    # => [slot_p, slot_s, KEY, SHARE_AMOUNT]
    exec.add_to_map_item
    # => []
end

#! Inputs:  [user_id_prefix, user_id_suffix, lp_withdraw_amount, 0, ASSET_OUT, noteid, 0,0,0, liabilities, reserve, reserve_with_slippage]
pub proc withdraw
    dupw
    # => [user_id_prefix, user_id_suffix, lp_withdraw_amount, 0, user_id_prefix, user_id_suffix, lp_withdraw_amount, 0, ASSET_OUT, noteid, 0,0,0, liabilities, reserve, reserve_with_slippage, 0]
    dupw.2
    # => [ASSET_OUT, user_id_prefix, user_id_suffix, lp_withdraw_amount, 0, user_id_prefix, user_id_suffix, lp_withdraw_amount, 0, ASSET_OUT, noteid, 0,0,0, liabilities, reserve, reserve_with_slippage, 0]
    exec.get_user_deposit_key
    # => [KEY, lp_withdraw_amount, 0, user_id_prefix, user_id_suffix, lp_withdraw_amount, 0, ASSET, noteid, 0,0,0, liabilities, reserve, reserve_with_slippage, 0 ]
    mem_storew_be.WITHDRAW_KEY_LOC
    exec.get_user_deposit
    # => [user_lp_shares, lp_withdraw_amount, 0, user_id_prefix, user_id_suffix, lp_withdraw_amount, 0, ASSET, noteid, 0,0,0, liabilities, reserve, reserve_with_slippage, 0]
    swap sub
    # => [new_user_lp_shares, 0, user_id_prefix, user_id_suffix, lp_withdraw_amount, 0, ASSET, noteid, 0,0,0, liabilities, reserve, reserve_with_slippage, 0 ]
    dup
    # => [new_user_lp_shares, new_user_lp_shares, 0, user_id_prefix, user_id_suffix, lp_withdraw_amount, 0, ASSET, noteid, 0,0,0, liabilities, reserve, reserve_with_slippage, 0]
    padw mem_loadw_be.WITHDRAW_KEY_LOC
    exec.get_user_deposit
    # => [user_lp_shares, new_user_lp_shares, new_user_lp_shares, 0, user_id_prefix, user_id_suffix, lp_withdraw_amount, 0, ASSET, noteid, 0,0,0, liabilities, reserve, reserve_with_slippage, 0]
    lt assert.err=ERR_LP_WITHDRAW_AMOUNT_EXCEEDS_USER_LP_SHARES
    # => [new_user_lp_shares, 0, user_id_prefix, user_id_suffix, lp_withdraw_amount, 0, ASSET, noteid, 0,0,0, liabilities, reserve, reserve_with_slippage, 0]

    # store new user lp shares
    push.0.0.0
    # => [NEW_USER_LP_SHARES, 0, user_id_prefix, user_id_suffix, lp_withdraw_amount, 0, ASSET, noteid, 0,0,0, liabilities, reserve, reserve_with_slippage, 0]
    padw mem_loadw_be.WITHDRAW_KEY_LOC
    push.USER_DEPOSITS_MAPPING_SLOT[0..2]
    # => [slot_p, slot_s, KEY, NEW_USER_LP_SHARES]
    exec.native_account::set_map_item
    dropw drop
    # => [user_id_prefix, user_id_suffix, lp_withdraw_amount, 0, ASSET, noteid, 0,0,0, liabilities, reserve, reserve_with_slippage, 0]
    drop drop swap drop
    mem_store.LP_SHARES_AMOUNT_ADDR


    mem_load.LP_SHARES_AMOUNT_ADDR push.0.0.0
    padw mem_loadw_be.WITHDRAW_KEY_LOC
    exec.get_lp_shares_total_supply_key
    # => [KEY, SHARE_AMOUNT]
    push.USER_DEPOSITS_MAPPING_SLOT[0..2]
    # => [slot_p, slot_s, KEY, SHARE_AMOUNT]
    exec.sub_from_map_item
    # => [ ASSET_OUT, noteid, 0,0,0, liabilities, reserve, reserve_with_slippage, 0]
    exec.move_asset_to_note
    dropw dropw dropw
end


#! Inputs: [slot_p, slot_s, KEY, VALUE]
#! Outputs: []
proc add_to_map_item
    # Save slot ID to memory
    mem_store.HELPER_SLOT_P_LOC
    mem_store.HELPER_SLOT_S_LOC
    # => [KEY, VALUE]

    # Duplicate KEY for second call
    dupw
    # => [KEY, KEY, VALUE]

    # Load slot ID and get current map value
    mem_load.HELPER_SLOT_S_LOC
    mem_load.HELPER_SLOT_P_LOC
    # => [slot_p, slot_s, KEY, KEY, VALUE]
    exec.active_account::get_map_item drop drop drop
    # => [old_amount, KEY, VALUE]

    # Add new amount to old amount
    movup.8 add
    # => [new_amount, KEY, 0, 0, 0]
    movdn.7
    # => [KEY, 0, 0, 0, new_amount]
    # => [KEY, NEW_VALUE]

    # Load slot ID and set map item
    mem_load.HELPER_SLOT_S_LOC
    mem_load.HELPER_SLOT_P_LOC
    # => [slot_p, slot_s, KEY, NEW_VALUE]
    exec.native_account::set_map_item dropw
    # => []
end

#! Inputs: [slot_p, slot_s, KEY, VALUE]
#! Outputs: []
proc sub_from_map_item
    # Save slot ID to memory
    mem_store.HELPER_SLOT_P_LOC
    mem_store.HELPER_SLOT_S_LOC
    # => [KEY, VALUE]

    # Duplicate KEY for second call
    dupw
    # => [KEY, KEY, VALUE]

    # Load slot ID and get current map value
    mem_load.HELPER_SLOT_S_LOC
    mem_load.HELPER_SLOT_P_LOC
    # => [slot_p, slot_s, KEY, KEY, VALUE]
    exec.active_account::get_map_item drop drop drop
    # => [old_amount, KEY, VALUE]

    # Subtract new amount from old amount
    movup.8
    sub
    # => [new_amount, KEY, 0, 0, 0]
    movdn.7
    # => [KEY, 0, 0, 0, new_amount]
    # => [KEY, NEW_VALUE]

    # Load slot ID and set map item
    mem_load.HELPER_SLOT_S_LOC
    mem_load.HELPER_SLOT_P_LOC
    # => [slot_p, slot_s, KEY, NEW_VALUE]
    exec.native_account::set_map_item dropw
    # => []
end

#! Returns user LP shares amount
#!
#! Inputs: [KEY]
#! Outputs: [share_amount]
#!
proc get_user_deposit
    # => [KEY]
    push.USER_DEPOSITS_MAPPING_SLOT[0..2]
    exec.active_account::get_map_item
    drop drop drop
    # => [share_amount]
end


#! Returns user LP shares mapping  key
#!
#! Inputs: [ASSET, user_id_suffix, user_id_prefix]
#! Outputs: [KEY]
#!
proc get_user_deposit_key
    exec.address_from_asset
    # => [asset_account_prefix, asset_account_suffix, user_id_suffix, user_id_prefix]
    # => [KEY]
end

#! Returns user LP shares mapping  key
#!
#! Inputs: [ASSET]
#! Outputs: [KEY]
#!
proc get_lp_shares_total_supply_key
    exec.address_word_from_asset
end

#! Returns user LP shares emitted for deposit amount
#!
#! Inputs: [amount, KEY]
#! Outputs: [share_amount]
#!
proc compute_deposit_shares
    # @todo: implement
    movdn.4 dropw
end

#! Returns asset amount worth of LP shares
#!
#! Inputs: [share_amount, ASSET]
#! Outputs: [UPDATED_ASSET]
#!
proc compute_withdraw_amount
    # @todo: implement
    swap.4 drop
end


#! Returns ASSET AMMOUNT
#! Inputs: [ASSET]
#! Outputs: [amount]
#!
proc extract_asset_amount
    drop drop drop
end




#! UTILS
#! Returns ASSET ADDRESS followd by two 0 felts
#!
#! Inputs: [ASSET]
#! Outputs: [asset_accout_prefix, asset_account_suffix, 0, 0]
#!
proc address_word_from_asset
    push.0 swap.3 drop
    push.0 swap.4 drop
end

#! Returns ASSET ADDRESS
#!
#! Inputs: [ASSET]
#! Outputs: [asset_accout_prefix, asset_account_suffix]
#!
proc address_from_asset
    swap.2 drop
    swap.2 drop
end
