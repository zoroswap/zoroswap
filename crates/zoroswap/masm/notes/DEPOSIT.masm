use.miden::active_note
use.miden::output_note
use.std::crypto::hashes::rpo
use.std::sys

use.zoro::zoropool

# ERRORS
# =================================================================================================

# DEPOSIT script expects exactly 9 note inputs
const.ERR_DEPOSIT_WRONG_NUMBER_OF_INPUTS="DEPOSIT wrong number of inputs"
# DEPOSIT script requires exactly one note asset
const.ERR_DEPOSIT_WRONG_NUMBER_OF_ASSETS="DEPOSIT wrong number of assets"


# CONSTANTS
# =================================================================================================

const.PUBLIC_NOTE=1
const.EXECUTION_HINT_ALWAYS=1

# MEMORY
# =================================================================================================

# first 4 WORDS reserved as scratch space
# ====================================================
# next 8  WORDS reserved for inputs
# ====================================================
# next 4  WORDS reserved for arguments
# ====================================================

const.INPUTS_POINTER = 0x0010



const.INPUTS_WORD_0 = INPUTS_POINTER        # [min_lp_amount_out, deadline, p2id_tag, empty]
const.INPUTS_WORD_1 = INPUTS_POINTER + 4    # [BENEFICIARY_ID_WORD] = [empty, empty, beneficiary_id_suffix, beneficiary_id_prefix]



# first 2 WORDS of input space used for inputs
# ====================================================
const.NUMBER_OF_INPUTS = 0x0008 # 8


# semantic names for inputs
# ====================================================
# [min_lp_amount_outdeadline, p2id_tag, empty, empty]
const.INPUT_PARAMS = INPUTS_WORD_0
const.BENEFICIARY_ID_WORD = INPUTS_WORD_1



# DEPOSIT Note Inputs (16 to 24)
# [min_amount_out, empty, out_asset_id_suffix, out_asset_id_prefix]
const.MIN_LP_AMOUNT_OUT = INPUT_PARAMS  # 0x0010
const.DEADLINE = INPUT_PARAMS + 1
const.P2ID_TAG = INPUT_PARAMS + 2

# [empty, empty, beneficiary_id_suffix, beneficiary_id_prefix]
const.EMPTY_INPUT_4 = BENEFICIARY_ID_WORD # 0x0018
const.EMPTY_INPUT_5 = BENEFICIARY_ID_WORD + 1
const.DEPOSIT_BENEFICIARY_ID_SUFFIX = BENEFICIARY_ID_WORD + 2
const.DEPOSIT_BENEFICIARY_ID_PREFIX = BENEFICIARY_ID_WORD + 3  # 0x001B

# EMPTY  5WORDS 0X001C- 0x00

# argument memory 4 WORDS 
# 0x0040 - 0x004F
# ====================================================

const.ARGS_POINTER = 0x0040


const.ARGS_WORD_0 = ARGS_POINTER        # []

# first 3 WORDS of ARGUMENTS space used for args
# ====================================================
const.NUMBER_OF_ARGS = 0x000C # 4

# semantic names for inputs
# ====================================================

const.LP_AMOUNT_OUT = ARGS_WORD_0   # 0x0040
const.LIABILITIES = ARGS_WORD_0 + 1  # 0x0041
const.RESERVE = ARGS_WORD_0 + 2  # 0x0042
const.RESERVE_WITH_SLIPPAGE = ARGS_WORD_0 + 3  # 0x0043


# memory addresses of the assets
const.DEPOSIT_ASSET_WORD = 0x0060
# memory locations based on IN_ASSET_WORD
const.DEPOSIT_AMOUNT = DEPOSIT_ASSET_WORD
const.DEPOSIT_ASSET_EMPTY_FELT = DEPOSIT_ASSET_WORD + 1
const.DEPOSIT_ASSET_ID_PREFIX = DEPOSIT_ASSET_WORD + 3
const.DEPOSIT_ASSET_ID_SUFFIX = DEPOSIT_ASSET_WORD + 2


# "constant" MEMORY
# =================================================================================================

const.P2ID_SCRIPT_ROOT_WORD = 0x0080


proc.store_asset_in_to_memory
    push.DEPOSIT_ASSET_WORD exec.active_note::get_assets assert.err=ERR_DEPOSIT_WRONG_NUMBER_OF_ASSETS
    drop
end

proc.store_inputs_to_memory
    # store note inputs into memory starting at address 0
    push.INPUTS_POINTER exec.active_note::get_inputs
    # => [num_inputs, inputs_ptr]
    # make sure the number of inputs is N
    eq.NUMBER_OF_INPUTS assert.err=ERR_DEPOSIT_WRONG_NUMBER_OF_INPUTS
    # => [inputs_ptr]
    drop

end
# @note TODO: pool stats will likely need to go through the advice stack
proc.store_args_to_memory
    mem_store.LIABILITIES
    mem_store.RESERVE
    mem_store.RESERVE_WITH_SLIPPAGE
    mem_store.LP_AMOUNT_OUT
end


#! Returns the P2ID RECIPIENT for a specified SERIAL_NUM, SCRIPT_HASH, and account_id
#!
#! Inputs: [SERIAL_NUM, SCRIPT_HASH]
#! Outputs: [P2ID_RECIPIENT]
#!
proc.build_p2id_recipient_hash

    padw hmerge
    # => [SERIAL_NUM_HASH, SCRIPT_HASH]
    swapw hmerge
    # => [SERIAL_SCRIPT_HASH]
    padw
    mem_load.DEPOSIT_BENEFICIARY_ID_SUFFIX mem_load.DEPOSIT_BENEFICIARY_ID_PREFIX
    push.0.0

    push.4000 mem_storew_be dropw
    push.4004 mem_storew_be dropw

    push.8.4000
    # => [ptr, elements]
    exec.rpo::hash_memory
    # => [INPUTS_HASH, SERIAL_SCRIPT_HASH]
    hmerge
    # => [P2ID_RECIPIENT]
end

# input: [SERIAL_NUM,...]
# ouput: [P2ID_SERIAL_NUM, ...]
proc.get_p2id_serial_num
    add.1
end

#! Creates a P2ID note to beneficiary
#!
#! Inputs: [ASSET_TO_BE_SENT]
#! Outputs: []
#!
proc.create_p2id_reverse_note
    # @dev prepad to not to destroy ASSET_TO_BE_SENT by note creation
    # @dev if doesnt work, use memory for ASSET_TO_BE_SENT
    padw padw
    # => [pad(8), ASSET_TO_BE_SENT]
    padw mem_loadw_be.P2ID_SCRIPT_ROOT_WORD
    # => [P2ID_SCRIPT_HASH, pad(8), ASSET_TO_BE_SENT]
    exec.active_note::get_serial_number
    # => [P2ID_SERIAL_NUM, , P2ID_SCRIPT_HASH, pad(8), ASSET_TO_BE_SENT]
    exec.get_p2id_serial_num
    # => [P2ID_SERIAL_NUM, P2ID_SCRIPT_HASH, pad(8), ASSET_TO_BE_SENT]
    exec.build_p2id_recipient_hash
    # => [P2ID_RECIPIENT, pad(8), ASSET_TO_BE_SENT]


    push.EXECUTION_HINT_ALWAYS
    # => [execution_hint_always, P2ID_RECIPIENT, pad(8), ASSET_TO_BE_SENT]
    push.PUBLIC_NOTE
    # => [public_note, execution_hint_always, P2ID_RECIPIENT, pad(8), ASSET_TO_BE_SENT]
    push.0 # @dev aux for p2id output note
    # => [aux, public_note, execution_hint_always, P2ID_RECIPIENT, pad(8), ASSET_TO_BE_SENT]
    mem_load.P2ID_TAG
    # => [tag, aux, public_note, execution_hint_always, P2ID_RECIPIENT, pad(8), ASSET_TO_BE_SENT]
    # => [tag, aux, note_type, execution_hint, RECIPIENT, pad(8), ASSET_TO_BE_SENT]
    call.output_note::create
    # => [note_idx, pad(15), ASSET_TO_BE_SENT]
    swapw.2 dropw swapw.3
    # => [ASSET, note_idx, pad(11)]
    padw mem_loadw_be.260 # load new out pool state

    swapw.2 swapw
    
    call.zoropool::bounce_asset
    # => [ASSET, note_idx, pad(3), NEW_OUT_POOL_STATE, pad(4)]
    dropw dropw drop
    # => []
end

proc.store_p2id_script_hash
    push.15783632360113277539.7403765918285273520.15691985194755641846.10399643920503194563
    mem_storew_be.P2ID_SCRIPT_ROOT_WORD dropw
end

proc.execute_DEPOSIT
    mem_load.LP_AMOUNT_OUT
    mem_load.MIN_LP_AMOUNT_OUT
    lt
    # min amount out is not met

    if.true
        mem_loadw_be.DEPOSIT_ASSET_WORD
        exec.create_p2id_reverse_note
    else
        mem_load.LP_AMOUNT_OUT mem_load.DEPOSIT_BENEFICIARY_ID_SUFFIX mem_load.DEPOSIT_BENEFICIARY_ID_PREFIX
        # => [beneficiary_id_prefix, beneficiary_id_suffix]
        push.0 mem_load.RESERVE_WITH_SLIPPAGE mem_load.RESERVE mem_load.LIABILITIES
         # => [liabilities,reserve, reserve_with_slippage, 0, beneficiary_id_prefix, beneficiary_id_suffix]
        push.0.0.0.0
        mem_loadw_be.DEPOSIT_ASSET_WORD
        # => [ASSET, liabilities,reserve, reserve_with_slippage, 0, beneficiary_id_prefix, beneficiary_id_suffix]
    
        call.zoropool::deposit

    end



    #mem_load.POOL0_RESERVE_WITH_SLIPPAGE mem_load.POOL0_RESERVE mem_load.POOL0_LIABILITIES 
    #call.zoropool::set_pool0_state
end

begin
    exec.store_args_to_memory

    exec.store_inputs_to_memory

    exec.store_asset_in_to_memory

    exec.store_p2id_script_hash

    exec.execute_DEPOSIT

    exec.sys::truncate_stack
end
