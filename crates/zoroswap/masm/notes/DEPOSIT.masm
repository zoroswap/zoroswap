use miden::protocol::active_note
use miden::protocol::output_note
use miden::core::crypto::hashes::rpo256
use miden::core::sys

use zoroswap::zoropool

# ERRORS
# =================================================================================================

# DEPOSIT script expects exactly 9 note inputs
const ERR_DEPOSIT_WRONG_NUMBER_OF_INPUTS="DEPOSIT wrong number of inputs"
# DEPOSIT script requires exactly one note asset
const ERR_DEPOSIT_WRONG_NUMBER_OF_ASSETS="DEPOSIT wrong number of assets"


# CONSTANTS
# =================================================================================================

const PUBLIC_NOTE=1

# MEMORY
# =================================================================================================

# first 4 WORDS reserved as scratch space
# ====================================================
# next 8  WORDS reserved for inputs
# ====================================================
# next 4  WORDS reserved for arguments
# ====================================================

const INPUTS_POINTER = 0x0010



const INPUTS_WORD_0 = INPUTS_POINTER        # [min_lp_amount_out, deadline, p2id_tag, empty]
const INPUTS_WORD_1 = INPUTS_POINTER + 4    # [CREATOR_ID_WORD] = [empty, empty, creator_id_suffix, creator_id_prefix]



# first 2 WORDS of input space used for inputs
# ====================================================
const NUMBER_OF_INPUTS = 0x0008 # 8


# semantic names for inputs
# ====================================================
# [min_lp_amount_outdeadline, p2id_tag, empty, empty]
const INPUT_PARAMS = INPUTS_WORD_0
const CREATOR_ID_WORD = INPUTS_WORD_1



# DEPOSIT Note Inputs (16 to 24)
# [min_amount_out, empty, out_asset_id_suffix, out_asset_id_prefix]
const MIN_LP_AMOUNT_OUT = INPUT_PARAMS  # 0x0010
const DEADLINE = INPUT_PARAMS + 1
const P2ID_TAG = INPUT_PARAMS + 2

# [empty, empty, creator_id_suffix, creator_id_prefix]
const EMPTY_INPUT_4 = CREATOR_ID_WORD # 0x0018
const EMPTY_INPUT_5 = CREATOR_ID_WORD + 1
const DEPOSIT_CREATOR_ID_SUFFIX = CREATOR_ID_WORD + 2
const DEPOSIT_CREATOR_ID_PREFIX = CREATOR_ID_WORD + 3  # 0x001B

# EMPTY  5WORDS 0X001C- 0x00

# argument memory 4 WORDS 
# 0x0040 - 0x004F
# ====================================================

const ARGS_POINTER = 0x0040


const ARGS_WORD_0 = ARGS_POINTER        # []

# first 3 WORDS of ARGUMENTS space used for args
# ====================================================
const NUMBER_OF_ARGS = 0x000C # 4

# semantic names for inputs
# ====================================================

const LP_AMOUNT_OUT = ARGS_WORD_0   # 0x0040
const LIABILITIES = ARGS_WORD_0 + 1  # 0x0041
const RESERVE = ARGS_WORD_0 + 2  # 0x0042
const RESERVE_WITH_SLIPPAGE = ARGS_WORD_0 + 3  # 0x0043


# memory addresses of the assets
const DEPOSIT_ASSET_WORD = 0x0060
# memory locations based on IN_ASSET_WORD
const DEPOSIT_AMOUNT = DEPOSIT_ASSET_WORD
const DEPOSIT_ASSET_EMPTY_FELT = DEPOSIT_ASSET_WORD + 1
const DEPOSIT_ASSET_ID_PREFIX = DEPOSIT_ASSET_WORD + 3
const DEPOSIT_ASSET_ID_SUFFIX = DEPOSIT_ASSET_WORD + 2


# "constant" MEMORY
# =================================================================================================

const P2ID_SCRIPT_ROOT_WORD = 0x0080


proc store_asset_in_to_memory
    push.DEPOSIT_ASSET_WORD exec.active_note::get_assets assert.err=ERR_DEPOSIT_WRONG_NUMBER_OF_ASSETS
    drop
end

proc store_inputs_to_memory
    # store note inputs into memory starting at address 0
    push.INPUTS_POINTER exec.active_note::get_inputs
    # => [num_inputs, inputs_ptr]
    # make sure the number of inputs is N
    eq.NUMBER_OF_INPUTS assert.err=ERR_DEPOSIT_WRONG_NUMBER_OF_INPUTS
    # => [inputs_ptr]
    drop

end
# @note TODO: pool stats will likely need to go through the advice stack
proc store_args_to_memory
    mem_store.LIABILITIES
    mem_store.RESERVE
    mem_store.RESERVE_WITH_SLIPPAGE
    mem_store.LP_AMOUNT_OUT
end


#! Returns the P2ID RECIPIENT for a specified SERIAL_NUM, SCRIPT_HASH, and account_id
#!
#! Inputs: [SERIAL_NUM, SCRIPT_HASH]
#! Outputs: [P2ID_RECIPIENT]
#!
proc build_p2id_recipient_hash

    padw hmerge
    # => [SERIAL_NUM_HASH, SCRIPT_HASH]
    swapw hmerge
    # => [SERIAL_SCRIPT_HASH]

    # Compute inputs commitment: hash_elements([suffix, prefix])
    # Must match build_p2id_recipient() from miden_standards which internally
    # computes NoteInputs::new(vec![suffix, prefix]).commitment() via
    # Rpo256::hash_elements(&[suffix, prefix])
    #
    # mem_storew_le stores in little-endian: stack[0]→pos0, stack[1]→pos1, etc.
    # hash_elements (via mem_stream) reads pos0 first → rate[0], pos1 → rate[1]
    # So we need suffix on top (it goes to pos0) and prefix below (pos1)
    # padw
    push.0.0

    mem_load.DEPOSIT_CREATOR_ID_PREFIX mem_load.DEPOSIT_CREATOR_ID_SUFFIX

    push.4000 mem_storew_le dropw
    # => mem[4000] pos0=suffix, pos1=prefix (LE), stack=[SERIAL_SCRIPT_HASH]

    push.2.4000
    # => [ptr=4000, num_elements=2, SERIAL_SCRIPT_HASH]
    exec.rpo256::hash_elements
    # => [INPUTS_COMMITMENT, SERIAL_SCRIPT_HASH]
    hmerge
    # => [P2ID_RECIPIENT]

end

# input: [SERIAL_NUM,...]
# ouput: [P2ID_SERIAL_NUM, ...]
proc get_p2id_serial_num
    add.1
end

#! Creates a P2ID note to creator
#!
#! Inputs: [ASSET_TO_BE_SENT]
#! Outputs: []
#!
proc create_p2id_reverse_note
    # prepad to keep ASSET_TO_BE_SENT below the 16-element call frame
    # We need 16 elements above ASSET before call.output_note::create:
    #   tag(1) + note_type(1) + RECIPIENT(4) + pad(10) = 16
    padw padw push.0.0
    # => [pad(10), ASSET_TO_BE_SENT]
    padw mem_loadw_be.P2ID_SCRIPT_ROOT_WORD
    # => [P2ID_SCRIPT_HASH, pad(8), ASSET_TO_BE_SENT]
    exec.active_note::get_serial_number
    # => [P2ID_SERIAL_NUM, , P2ID_SCRIPT_HASH, pad(8), ASSET_TO_BE_SENT]
    exec.get_p2id_serial_num
    # => [P2ID_SERIAL_NUM, P2ID_SCRIPT_HASH, pad(8), ASSET_TO_BE_SENT]
    exec.build_p2id_recipient_hash
    # => [P2ID_RECIPIENT, pad(8), ASSET_TO_BE_SENT]


    push.PUBLIC_NOTE
    # => [note_type, P2ID_RECIPIENT, pad(8), ASSET_TO_BE_SENT]
    mem_load.P2ID_TAG
    # => [tag, note_type, P2ID_RECIPIENT, pad(8), ASSET_TO_BE_SENT]
    call.output_note::create
    # => [note_idx, pad(15), ASSET_TO_BE_SENT]
    swapw.2 dropw swapw.3
    # => [ASSET, note_idx, pad(11)]
    padw mem_loadw_be.260 # load new out pool state

    swapw.2 swapw
    
    call.zoropool::bounce_asset
    # => [ASSET, note_idx, pad(3), NEW_OUT_POOL_STATE, pad(4)]
    dropw dropw drop
    # => []
end

proc store_p2id_script_hash
    # P2ID script root from miden-standards v0.13 WellKnownNote::P2ID.script_root()
    push.13362761878458161062.15090726097241769395.444910447169617901.3558201871398422326
    mem_storew_be.P2ID_SCRIPT_ROOT_WORD dropw
end

proc execute_DEPOSIT
    mem_load.LP_AMOUNT_OUT
    mem_load.MIN_LP_AMOUNT_OUT
    lt
    # min amount out is not met

    if.true
        mem_loadw_be.DEPOSIT_ASSET_WORD
        exec.create_p2id_reverse_note
    else
        mem_load.LP_AMOUNT_OUT mem_load.DEPOSIT_CREATOR_ID_SUFFIX mem_load.DEPOSIT_CREATOR_ID_PREFIX
        # => [creator_id_prefix, creator_id_suffix]
        push.0 mem_load.RESERVE_WITH_SLIPPAGE mem_load.RESERVE mem_load.LIABILITIES 
         # => [liabilities,reserve, reserve_with_slippage, 0, creator_id_prefix, creator_id_suffix]
        push.0.0.0.0
        mem_loadw_be.DEPOSIT_ASSET_WORD
        # => [ASSET, liabilities,reserve, reserve_with_slippage, 0, creator_id_prefix, creator_id_suffix]
    
        call.zoropool::deposit

    end



    #mem_load.POOL0_RESERVE_WITH_SLIPPAGE mem_load.POOL0_RESERVE mem_load.POOL0_LIABILITIES 
    #call.zoropool::set_pool0_state
end

begin
    exec.store_args_to_memory

    exec.store_inputs_to_memory

    exec.store_asset_in_to_memory

    exec.store_p2id_script_hash

    exec.execute_DEPOSIT

    exec.sys::truncate_stack
end
