use anyhow::Result;
use miden_client::{
    ClientError, Felt, Word,
    account::AccountId,
    note::{
        Note, NoteAssets, NoteError, NoteExecutionHint, NoteMetadata, NoteRecipient, NoteScript,
        NoteTag, NoteType,
    },
};
use miden_lib::{note::utils::build_p2id_recipient, transaction::TransactionKernel};
use std::{fs, path::PathBuf};
use tracing::{debug, info};

use crate::Config;
use zoro_miden_client::MidenClient;

// --------------------------------------------------------------------------
// Zoro-Specific Helper Functions
// --------------------------------------------------------------------------

/// Prints a clickable MidenScan URL for a transaction.
pub fn print_transaction_info(tx: &miden_client::transaction::TransactionId) {
    println!(
        "View transaction on MidenScan: https://testnet.midenscan.com/tx/{}",
        tx.to_hex()
    );
}

/// Prints a clickable MidenScan URL for a note.
pub fn print_note_info(note_id: &miden_client::note::NoteId) {
    println!(
        "View note on MidenScan: https://testnet.midenscan.com/note/{}",
        note_id.to_hex()
    );
}

// --------------------------------------------------------------------------
// Zoro-Specific Storage Configuration
// --------------------------------------------------------------------------

#[derive(Eq, PartialEq, Debug)]
pub enum ZoroStoragePurpose {
    AmmState,
    Faucet,
    Trading,
    Listening,
}

pub struct ZoroStorageSettings {
    path: String,
    purpose: ZoroStoragePurpose,
}

impl ZoroStorageSettings {
    pub fn ammstate_storage(store_path: String) -> Self {
        ZoroStorageSettings {
            path: store_path,
            purpose: ZoroStoragePurpose::AmmState,
        }
    }

    pub fn faucet_storage(store_path: String) -> Self {
        ZoroStorageSettings {
            path: store_path,
            purpose: ZoroStoragePurpose::Faucet,
        }
    }

    pub fn trading_storage(store_path: String) -> Self {
        ZoroStorageSettings {
            path: store_path,
            purpose: ZoroStoragePurpose::Trading,
        }
    }

    pub fn listening_storage(store_path: String) -> Self {
        ZoroStorageSettings {
            path: store_path,
            purpose: ZoroStoragePurpose::Listening,
        }
    }
}

// --------------------------------------------------------------------------
// Zoro-Specific Client Initialization
// --------------------------------------------------------------------------

/// Instantiates a Miden client with Zoro-specific configuration.
///
/// This includes:
/// - Importing the pool account
/// - Importing all faucets from liquidity pools
/// - Adding note tags for pool monitoring
pub async fn instantiate_client(
    config: &Config,
    storage: ZoroStorageSettings,
) -> Result<MidenClient, ClientError> {
    use miden_client::{
        DebugMode, builder::ClientBuilder, keystore::FilesystemKeyStore, rpc::GrpcClient,
    };
    use miden_client_sqlite_store::ClientBuilderSqliteExt;
    use std::sync::Arc;

    info!("Creating a new Miden Client for {:?}", storage.purpose);
    info!("Keystore path from config: {}", config.keystore_path);
    let timeout_ms = 10_000;
    let rpc_api = Arc::new(GrpcClient::new(&config.miden_endpoint, timeout_ms));
    let keystore = FilesystemKeyStore::new(config.keystore_path.into())
        .unwrap_or_else(|err| {
            panic!(
                "Failed to create keystore at {}: {err:?}",
                config.keystore_path
            )
        })
        .into();
    let mut client = ClientBuilder::new()
        .rpc(rpc_api.clone())
        .authenticator(keystore)
        .sqlite_store(storage.path.into())
        .in_debug_mode(DebugMode::Enabled)
        .build()
        .await?;
    info!(
        "Adding accounts and tags to Miden client for {:?}.",
        storage.purpose
    );
    client.import_account_by_id(config.pool_account_id).await?;
    for pool in &config.liquidity_pools {
        info!("Importing faucet: {}", pool.faucet_id.to_hex());
        client.get_account(pool.faucet_id).await?;
        client.sync_state().await?;
    }
    client
        .add_note_tag(NoteTag::from_account_id(config.pool_account_id))
        .await?;
    client.sync_state().await?;
    info!(
        "Miden client for {:?} synced and ready for use.",
        storage.purpose
    );
    Ok(client)
}

// --------------------------------------------------------------------------
// Zoro-Specific Note Creation
// --------------------------------------------------------------------------

/// Creates the P2ID recipient that will be generated by the `ZOROSWAP.masm` script.
///
/// The ZOROSWAP script creates a P2ID note with:
/// - Serial number:
///   `[swap_serial_num[0] + 1, swap_serial_num[1], swap_serial_num[2], swap_serial_num[3]]`
/// - Script: `P2ID.masm` (using the hash stored via `proc.store_p2id_script_hash`)
/// - Inputs: `[creator_id.suffix(), creator_id.prefix()]`
pub fn create_expected_p2id_recipient(
    swap_serial_num: Word,
    creator_id: AccountId,
) -> Result<NoteRecipient, NoteError> {
    // Calculate P2ID serial number (increment first element by 1)
    let p2id_serial_num: Word = [
        swap_serial_num[0] + Felt::new(1),
        swap_serial_num[1],
        swap_serial_num[2],
        swap_serial_num[3],
    ]
    .into();

    debug!("P2ID creator id: {:?}", creator_id);
    debug!("P2ID serial num: {:?}", p2id_serial_num);
    let recipient = build_p2id_recipient(creator_id, p2id_serial_num)?;
    debug!("P2ID recipient digest: {:?}", recipient.digest());
    Ok(recipient)
}

/// Creates a ZOROSWAP note using the ZOROSWAP.masm script.
///
/// This is specific to the Zoro AMM protocol.
pub fn create_zoroswap_note(
    inputs: Vec<Felt>,
    assets: Vec<miden_client::asset::Asset>,
    creator: AccountId,
    swap_serial_num: Word,
    note_tag: NoteTag,
    note_type: NoteType,
) -> Result<Note, NoteError> {
    use miden_client::note::NoteInputs;

    let manifest_dir = env!("CARGO_MANIFEST_DIR");
    let path: PathBuf = [manifest_dir, "masm", "notes", "ZOROSWAP.masm"]
        .iter()
        .collect();
    let note_code = fs::read_to_string(&path)
        .unwrap_or_else(|err| panic!("Error reading {}: {}", path.display(), err));
    let assembler = TransactionKernel::assembler()
        .with_debug_mode(true)
        .with_warnings_as_errors(true);
    let program = assembler
        .assemble_program(note_code)
        .unwrap_or_else(|err| panic!("Failed to assemble program: {err:?}"));
    let note_script = NoteScript::new(program);
    let aux = Felt::new(0);

    let inputs = NoteInputs::new(inputs)?;
    // build the outgoing note
    let metadata = NoteMetadata::new(
        creator,
        note_type,
        note_tag,
        NoteExecutionHint::always(),
        aux,
    )?;

    let assets = NoteAssets::new(assets)?;
    let recipient = NoteRecipient::new(swap_serial_num, note_script.clone(), inputs.clone());
    let note = Note::new(assets.clone(), metadata, recipient.clone());

    Ok(note)
}
